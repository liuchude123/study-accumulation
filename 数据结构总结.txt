程序设计=数据结构+算法

一、数据结构

    数据：描述客观事物的符号，是计算机中可以操作的对象。包括整型、实型等数值类型，字符、声音、图像、视频等非数值类型
数据对象：性质相同的数据元素的集合，是数据的子集
数据元素：组成数据的基本单位，计算机中通常作为整体处理。如：人类的数据元素->人。。。
  数据项：一个数据源元素可以由若干个数据项组成，是数据不可分割的最小单位。如：人这个数据元素，可以有姓名，性别，手，脚等数据项

数据结构：相互之间存在一种或多种特定关系的数据元素的集合。数据结构分为逻辑结构和物理结构

逻辑结构：数据对象中数据数据元素之间的相互关系。分为集合结构、线性结构、树形机构、图形结构四种逻辑结构
1>.集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其它关系。类似数学中集合
2>.线性结构：线性结构中的数据元素之间是一对一的关系
3>.树形结构：树形结构中的数据元素之间是一对多的层次关系
4>.图形结构：图形结构中的数据元素之间是多对多的关系
物理机构：数据的逻辑结构在计算机中的存储形式，目的是将数据及逻辑关系存储到计算机内存中。分为顺序存储结构和链式存储结构两种物理机构
1>.顺序存储机构：是把数据元素存放在连续的存储单元里面，其数据间逻辑关系和物理关系是一致的。如：数组就是顺序存储结构
2>.链式存储结构：
是把数据元素存放在任意的存储单元里面，这组存储单元可以使连续的，也可以是不连续的。
数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联的数据元素的位置



二、算法

算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作

算法具有五个基本特性：输入、输出、有穷性、确定性、可行性
1>.  输入：算法具有零个或多个输入
2>.  输出：算法至少有一个或多个输出
3>.有穷性：指算法在执行有限步骤之后，自动结束而不会出现无限循环，并且每个步骤在可接受时间内完成
4>.确定性：算法在一定条件下，只有一条执行路径，相同的输入只有唯一的输出
5>.可行性：算法的每一步骤都能通过执行有限的次数完成

算法设计要求：
1>.正确性：指算法至少应具有输入输出，能够得到问题的正确答案
2>.可读性：算法设计的另一目的是为了便于阅读、理解和交流
3>.健壮性：当输入不合法时，算法也能做出相关处理，而不是产生异常或命名奇妙的结果
4>.时间效率高
5>.存储量低

算法时间复杂度：
推导大O阶
整数阶  对数阶    线性阶   nlogn阶    平方阶   立方阶   指数阶  
O(1)    <O(logn)  <O(n)    <O(nlogn)  <O(n^2)  <O(n^3)  <O(2^n)   <O(n!)   <O(n^n)

算法空间复杂度：



三、线性表

线性表是零个或多个数据元素的有限序列。元素之间有顺序，若元素存在多个，则第一个无前驱，最后一个无后继，其余元素都有且只有一个前驱和后继

线性表的顺序存储结构：指用一段地址连续的存储单元依次存储线性表的数据元素
如：一维数组。数组长度：存放线性表的存储空间的长度。线性表长度：线性表中数据元素的个数

线性表顺序存储结构插入操作(插队)：线性表L第i【i>=1&&i<=L->length】个位置之前插入新数据元素e
如果插入位置不合理，抛出异常；【i<1||i>L->length+1】
如果线性表长度大于等于数组长度，则抛出异常或动态增加容量【L->length==MAXSIZE】
从最后一个元素开始遍历到第i个位置，分别将它们都向后移动一个位置；
将要插入的元素填入位置i处；【L->data[i-1]=e】
表长加1。【L->length++】

线性表顺序存储结构删除操作：
如果删除位置不合理，抛出异常；【i<1||i>L->length】
取出删除元素；
从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；
表长减一

线性表顺序存储结构优点：
1>.可以快速的存取表中任一位置元素*
2>.无须为表示表中元素之间逻辑关系而增加额外存储空间

线性表顺序存储结构缺点：
1>.插入和删除操作需要移动大量元素*
2>.当线性表长度变化较大时，难以确定存储空间的容量
3>.造成存储空间的碎片


线性表的链式存储结构：
1>.单链表
结点(Node)：数据域(存储数据元素信息)+指针域(存储直接后继地址)
N个节点链结成一个链表，即线性表的链式存储结构，链表的每个结点中只包含一个指针域，所以叫单链表

单链表的插入：p结点后面插入s结点
p    p->next
ai   ai+1

s->data=e;
s->next=p->next;
p->next=s;

单链表的删除：删除结点q(p->next)
p      q(p->next)    q->next(p->next->next)
ai-1   ai            ai+1

q=p->next;
p->next=q->next;
或p->next=p->next->next


2>.静态链表
用数组来代替指针，让数组元素都是由两个数据域组成，data和cur，数组的每个下标都对应一个data和一个cur，
cur游标相当于单链表中的next指针，存放该元素的后继在数组中的下标，把这种用数组描述的链表叫做静态链表

3>.循环链表
将单链表中终端结点的指针端由空指针改为只想头结点，使整个单链表形成一个环，这种头尾相接的单链表称为循环链表

4>.双向链表
是在单链表的每个结点中，再设置一个指向其前驱结点的指针域

双向链表的插入：p结点后面插入s结点
p    p->next
ai   ai+1

s->prior=p;
s->next=p->next;
p->next->prior=s;
p->next=s;


双向链表的删除：删除结点p
p->prior   p      p->next
ai-1       ai     ai+1

p->prior->next=p->next;
p->next->prior=p->prior;


四、栈和队列

栈：栈是限定仅在表尾进行插入和删除操作的线性表。后进先出的线性表，LIFO结构

栈的顺序存储
进栈：栈顶指针加1，将新插入的元素赋值给栈顶空间
s->top++;
s->data[s->top]=e;
出栈：将要删除的栈顶元素赋值给e，栈顶指针减1
s->top--;

栈的链式存储：链栈
进栈：
s->data=e;
s->next=s->top; //把当前的栈顶元素赋值给新结点的直接后继
s->top=s; //将新结点s赋值给栈顶指针
s->count++;
出栈：
p=s->top;
s->top=s->top->next;
free(p);
s->count--;

栈的应用：递归（斐波那契额数列）、四则运算表达式求值


队列：只允许在队尾插入操作，而在队头删除操作的线性表。队列是一种先进先出的线性表，FIFO结构

队列的顺序存储结构：循环队列
后面满了，就再从头开始，也就是头尾相连的循环，循环队列
循环队列入队：
Q->data[Q->rear]=e; //将新增元素e赋值给队尾
Q->rear=(Q->rear+1)%MAXSIZE; //rear指针向后移一位，若到最后则转到数组头部
循环队列出队：
*e=Q->data[Q->front]; // 将队头元素赋值给e
Q->front=(Q->front+1)%MAXSIZE; //front指针向后移一位，若到最后则转到数组头部

队列的顺序链式结构：链队列
链队列入队：
rear      s
an        e
s->data=e;
s->next=NULL;
Q->rear->next=s; // 把拥有元素e新结点s赋值给原队尾结点的后继
Q->rear=s; // 把当前的s设置为队尾结点
链队列出队：
front   front->next
        a1
p=Q->front->next; //将预删除的队头结点暂存给p
Q->front->next=p->next; //将原队头结点后继p->next赋值给头结点后继
if(Q->rear==p) //若队头是队尾则删除后将尾指针指向头结点
Q->rear=Q->front;






